diff '--exclude=.git' -urN a/gio/src/application.ccg b/gio/src/application.ccg
--- a/gio/src/application.ccg	2016-04-14 09:15:01.000000000 -0500
+++ b/gio/src/application.ccg	2019-04-10 17:13:07.572131907 -0500
@@ -344,9 +344,9 @@
     (*base->open)(self, files, n_files, hint);
 }
 
-Glib::SignalProxy2< void, const Application::type_vec_files&, const Glib::ustring& > Application::signal_open()
+Glib::SignalProxy< void, const Application::type_vec_files&, const Glib::ustring& > Application::signal_open()
 {
-  return Glib::SignalProxy2< void, const Application::type_vec_files&, const Glib::ustring& >(this, &Application_signal_open_info);
+  return Glib::SignalProxy< void, const Application::type_vec_files&, const Glib::ustring& >(this, &Application_signal_open_info);
 }
 
 void Gio::Application::on_open(const Application::type_vec_files& files, const Glib::ustring& hint)
diff '--exclude=.git' -urN a/gio/src/application.hg b/gio/src/application.hg
--- a/gio/src/application.hg	2016-04-14 09:15:01.000000000 -0500
+++ b/gio/src/application.hg	2019-04-10 17:13:07.572131907 -0500
@@ -380,7 +380,7 @@
 
   //We wrap the open signal without _WRAP_SIGNAL(), because we need to change its parameters.
   //See bug https://bugzilla.gnome.org/show_bug.cgi?id=637457
-  Glib::SignalProxy2< void,  const type_vec_files&, const Glib::ustring& > signal_open();
+  Glib::SignalProxy< void,  const type_vec_files&, const Glib::ustring& > signal_open();
   _IGNORE_SIGNAL(open)
 
 #m4 _CONVERSION(`GApplicationCommandLine*', `const Glib::RefPtr<ApplicationCommandLine>&',`Glib::wrap($3, true)')
diff '--exclude=.git' -urN a/glib/glibmm/filelist.am b/glib/glibmm/filelist.am
--- a/glib/glibmm/filelist.am	2016-04-14 09:15:01.000000000 -0500
+++ b/glib/glibmm/filelist.am	2019-04-10 17:13:07.572131907 -0500
@@ -69,6 +69,7 @@
 	random.h			\
 	refptr.h			\
 	sarray.h			\
+	signalproxy.h			\
 	signalproxy_connectionnode.h	\
 	slisthandle.h			\
 	streamiochannel.h		\
diff '--exclude=.git' -urN a/glib/glibmm/signalproxy.h b/glib/glibmm/signalproxy.h
--- a/glib/glibmm/signalproxy.h	2016-04-14 09:25:56.000000000 -0500
+++ b/glib/glibmm/signalproxy.h	2019-04-10 17:13:07.572131907 -0500
@@ -1,8 +1,25 @@
-/* This is a generated file, do not edit.  Generated from signalproxy.h.m4 */
-
 #ifndef _GLIBMM_SIGNALPROXY_H
 #define _GLIBMM_SIGNALPROXY_H
 
+/* signalproxy.h
+ *
+ * Copyright (C) 2015 The gtkmm Development Team
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
 extern "C"
 {
   typedef void (*GCallback) (void);
@@ -74,7 +91,7 @@
   void emission_stop();
 
 #ifndef DOXYGEN_SHOULD_SKIP_THIS
-  // This callback for SignalProxy0<void>
+  // This callback for SignalProxy<void>
   // is defined here to avoid code duplication.
   static void slot0_void_callback(GObject*, void* data);
 #endif
@@ -116,221 +133,20 @@
   SignalProxyNormal& operator=(const SignalProxyNormal&);
 };
 
-// Shared portion of a Signal with detail
-/** The SignalProxy provides an API similar to sigc::signal that can be used to
- * connect sigc::slots to glib signals.
- *
- * This holds the name of the glib signal, including the detail name if any,
- * and the object which might emit it. Actually, proxies are controlled by
- * the template derivatives, which serve as gatekeepers for the
- * types allowed on a particular signal.
- */
-class SignalProxyDetailed : public SignalProxyBase
-{
-public:
-  ~SignalProxyDetailed() noexcept;
-
-  /// Stops the current signal emission (not in libsigc++)
-  void emission_stop();
-
-protected:
-
-  /** Creates a proxy for a signal that can be emitted by @a obj.
-   * @param obj The object that can emit the signal.
-   * @param info Information about the signal, including its name
-   *             and the C callbacks that should be called by glib.
-   * @param detail_name The detail name, if any.
-   */
-  SignalProxyDetailed(Glib::ObjectBase* obj, const SignalProxyInfo* info, const Glib::ustring& detail_name);
-
-  /** Connects a signal handler to a signal.
-   * This is called by connect() and connect_notify() in derived SignalProxy classes.
-   *
-   * @param notify Whether this method is called by connect_notify() or by connect().
-   * @param slot The signal handler, usually created with sigc::mem_fun() or sigc::ptr_fun().
-   * @param after Whether this signal handler should be called before or after the default signal handler.
-   */
-  sigc::slot_base& connect_impl_(bool notify, const sigc::slot_base& slot, bool after);
-
-private:
-  const SignalProxyInfo* info_; // Pointer to statically allocated structure.
-  const Glib::ustring detailed_name_; // signal_name[::detail_name]
-
-  // no copy assignment
-  SignalProxyDetailed& operator=(const SignalProxyDetailed&);
-};
-
-
-/**** Glib::SignalProxy0 ***************************************************/
-
-/** Proxy for signals with 0 arguments.
- * Use the connect() or connect_notify() method, with sigc::mem_fun() or sigc::ptr_fun()
- * to connect signal handlers to signals.
- */
-template <class R>
-class SignalProxy0 : public SignalProxyNormal
-{
-public:
-  typedef sigc::slot<R>    SlotType;
-  typedef sigc::slot<void> VoidSlotType;
-
-  SignalProxy0(ObjectBase* obj, const SignalProxyInfo* info)
-    : SignalProxyNormal(obj, info) {}
-
-  /** Connects a signal handler to a signal.
-   *
-   * For instance, connect( sigc::mem_fun(*this, &TheClass::on_something) );
-   *
-   * @param slot The signal handler, usually created with sigc::mem_fun() or sigc::ptr_fun().
-   * @param after Whether this signal handler should be called before or after the default signal handler.
-   */
-  sigc::connection connect(const SlotType& slot, bool after = true)
-    { return sigc::connection(connect_(slot, after)); }
-
-  /** Connects a signal handler without a return value to a signal.
-   * By default, the signal handler will be called before the default signal handler.
-   *
-   * For instance, connect_notify( sigc::mem_fun(*this, &TheClass::on_something) );
-   *
-   * If the signal requires signal handlers with a @c void return type,
-   * the only difference between connect() and connect_notify() is the default
-   * value of @a after.
-   *
-   * If the signal requires signal handlers with a return value of type T,
-   * connect_notify() binds <tt>return T()</tt> to the connected signal handler.
-   * For instance, if the return type is @c bool, the following two calls are equivalent.
-   * @code
-   * connect_notify( sigc::mem_fun(*this, &TheClass::on_something) );
-   * connect( sigc::bind_return<bool>(sigc::mem_fun(*this, &TheClass::on_something), false), false );
-   * @endcode
-   *
-   * @param slot The signal handler, which should have a @c void return type,
-   *        usually created with sigc::mem_fun() or sigc::ptr_fun().
-   * @param after Whether this signal handler should be called before or after the default signal handler.
-   */
-  sigc::connection connect_notify(const VoidSlotType& slot, bool after = false)
-    { return sigc::connection(connect_notify_(slot, after)); }
-};
-
-
-/**** Glib::SignalProxy1 ***************************************************/
-
-/** Proxy for signals with 1 arguments.
- * Use the connect() or connect_notify() method, with sigc::mem_fun() or sigc::ptr_fun()
- * to connect signal handlers to signals.
- */
-template <class R,class P1>
-class SignalProxy1 : public SignalProxyNormal
-{
-public:
-  typedef sigc::slot<R,P1>    SlotType;
-  typedef sigc::slot<void,P1> VoidSlotType;
-
-  SignalProxy1(ObjectBase* obj, const SignalProxyInfo* info)
-    : SignalProxyNormal(obj, info) {}
-
-  /** Connects a signal handler to a signal.
-   *
-   * For instance, connect( sigc::mem_fun(*this, &TheClass::on_something) );
-   *
-   * @param slot The signal handler, usually created with sigc::mem_fun() or sigc::ptr_fun().
-   * @param after Whether this signal handler should be called before or after the default signal handler.
-   */
-  sigc::connection connect(const SlotType& slot, bool after = true)
-    { return sigc::connection(connect_(slot, after)); }
-
-  /** Connects a signal handler without a return value to a signal.
-   * By default, the signal handler will be called before the default signal handler.
-   *
-   * For instance, connect_notify( sigc::mem_fun(*this, &TheClass::on_something) );
-   *
-   * If the signal requires signal handlers with a @c void return type,
-   * the only difference between connect() and connect_notify() is the default
-   * value of @a after.
-   *
-   * If the signal requires signal handlers with a return value of type T,
-   * connect_notify() binds <tt>return T()</tt> to the connected signal handler.
-   * For instance, if the return type is @c bool, the following two calls are equivalent.
-   * @code
-   * connect_notify( sigc::mem_fun(*this, &TheClass::on_something) );
-   * connect( sigc::bind_return<bool>(sigc::mem_fun(*this, &TheClass::on_something), false), false );
-   * @endcode
-   *
-   * @param slot The signal handler, which should have a @c void return type,
-   *        usually created with sigc::mem_fun() or sigc::ptr_fun().
-   * @param after Whether this signal handler should be called before or after the default signal handler.
-   */
-  sigc::connection connect_notify(const VoidSlotType& slot, bool after = false)
-    { return sigc::connection(connect_notify_(slot, after)); }
-};
-
-
-/**** Glib::SignalProxy2 ***************************************************/
-
-/** Proxy for signals with 2 arguments.
- * Use the connect() or connect_notify() method, with sigc::mem_fun() or sigc::ptr_fun()
- * to connect signal handlers to signals.
- */
-template <class R,class P1,class P2>
-class SignalProxy2 : public SignalProxyNormal
-{
-public:
-  typedef sigc::slot<R,P1,P2>    SlotType;
-  typedef sigc::slot<void,P1,P2> VoidSlotType;
-
-  SignalProxy2(ObjectBase* obj, const SignalProxyInfo* info)
-    : SignalProxyNormal(obj, info) {}
-
-  /** Connects a signal handler to a signal.
-   *
-   * For instance, connect( sigc::mem_fun(*this, &TheClass::on_something) );
-   *
-   * @param slot The signal handler, usually created with sigc::mem_fun() or sigc::ptr_fun().
-   * @param after Whether this signal handler should be called before or after the default signal handler.
-   */
-  sigc::connection connect(const SlotType& slot, bool after = true)
-    { return sigc::connection(connect_(slot, after)); }
-
-  /** Connects a signal handler without a return value to a signal.
-   * By default, the signal handler will be called before the default signal handler.
-   *
-   * For instance, connect_notify( sigc::mem_fun(*this, &TheClass::on_something) );
-   *
-   * If the signal requires signal handlers with a @c void return type,
-   * the only difference between connect() and connect_notify() is the default
-   * value of @a after.
-   *
-   * If the signal requires signal handlers with a return value of type T,
-   * connect_notify() binds <tt>return T()</tt> to the connected signal handler.
-   * For instance, if the return type is @c bool, the following two calls are equivalent.
-   * @code
-   * connect_notify( sigc::mem_fun(*this, &TheClass::on_something) );
-   * connect( sigc::bind_return<bool>(sigc::mem_fun(*this, &TheClass::on_something), false), false );
-   * @endcode
-   *
-   * @param slot The signal handler, which should have a @c void return type,
-   *        usually created with sigc::mem_fun() or sigc::ptr_fun().
-   * @param after Whether this signal handler should be called before or after the default signal handler.
-   */
-  sigc::connection connect_notify(const VoidSlotType& slot, bool after = false)
-    { return sigc::connection(connect_notify_(slot, after)); }
-};
-
-
-/**** Glib::SignalProxy3 ***************************************************/
+/**** Glib::SignalProxy ***************************************************/
 
-/** Proxy for signals with 3 arguments.
+/** Proxy for signals with any number of arguments.
  * Use the connect() or connect_notify() method, with sigc::mem_fun() or sigc::ptr_fun()
  * to connect signal handlers to signals.
  */
-template <class R,class P1,class P2,class P3>
-class SignalProxy3 : public SignalProxyNormal
+template <class R, class ...T>
+class SignalProxy : public SignalProxyNormal
 {
 public:
-  typedef sigc::slot<R,P1,P2,P3>    SlotType;
-  typedef sigc::slot<void,P1,P2,P3> VoidSlotType;
+  typedef sigc::slot<R, T...>    SlotType;
+  typedef sigc::slot<void, T...> VoidSlotType;
 
-  SignalProxy3(ObjectBase* obj, const SignalProxyInfo* info)
+  SignalProxy(ObjectBase* obj, const SignalProxyInfo* info)
     : SignalProxyNormal(obj, info) {}
 
   /** Connects a signal handler to a signal.
@@ -368,489 +184,82 @@
     { return sigc::connection(connect_notify_(slot, after)); }
 };
 
+/* Templates below has been added to avoid API break, and should not be
+ * used in a newly created code. SignalProxy class should be used instead
+ * of SignalProxy# class.
+ */
+template <typename R>
+using SignalProxy0 = SignalProxy<R>;
+template <typename R, typename T1>
+using SignalProxy1 = SignalProxy<R, T1>;
+template <typename R, typename T1, typename T2>
+using SignalProxy2 = SignalProxy<R, T1, T2>;
+template <typename R, typename T1, typename T2, typename T3>
+using SignalProxy3 = SignalProxy<R, T1, T2, T3>;
+template <typename R, typename T1, typename T2, typename T3, typename T4>
+using SignalProxy4 = SignalProxy<R, T1, T2, T3, T4>;
+template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5>
+using SignalProxy5 = SignalProxy<R, T1, T2, T3, T4, T5>;
+template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
+using SignalProxy6 = SignalProxy<R, T1, T2, T3, T4, T5, T6>;
 
-/**** Glib::SignalProxy4 ***************************************************/
-
-/** Proxy for signals with 4 arguments.
- * Use the connect() or connect_notify() method, with sigc::mem_fun() or sigc::ptr_fun()
- * to connect signal handlers to signals.
- */
-template <class R,class P1,class P2,class P3,class P4>
-class SignalProxy4 : public SignalProxyNormal
-{
-public:
-  typedef sigc::slot<R,P1,P2,P3,P4>    SlotType;
-  typedef sigc::slot<void,P1,P2,P3,P4> VoidSlotType;
-
-  SignalProxy4(ObjectBase* obj, const SignalProxyInfo* info)
-    : SignalProxyNormal(obj, info) {}
-
-  /** Connects a signal handler to a signal.
-   *
-   * For instance, connect( sigc::mem_fun(*this, &TheClass::on_something) );
-   *
-   * @param slot The signal handler, usually created with sigc::mem_fun() or sigc::ptr_fun().
-   * @param after Whether this signal handler should be called before or after the default signal handler.
-   */
-  sigc::connection connect(const SlotType& slot, bool after = true)
-    { return sigc::connection(connect_(slot, after)); }
-
-  /** Connects a signal handler without a return value to a signal.
-   * By default, the signal handler will be called before the default signal handler.
-   *
-   * For instance, connect_notify( sigc::mem_fun(*this, &TheClass::on_something) );
-   *
-   * If the signal requires signal handlers with a @c void return type,
-   * the only difference between connect() and connect_notify() is the default
-   * value of @a after.
-   *
-   * If the signal requires signal handlers with a return value of type T,
-   * connect_notify() binds <tt>return T()</tt> to the connected signal handler.
-   * For instance, if the return type is @c bool, the following two calls are equivalent.
-   * @code
-   * connect_notify( sigc::mem_fun(*this, &TheClass::on_something) );
-   * connect( sigc::bind_return<bool>(sigc::mem_fun(*this, &TheClass::on_something), false), false );
-   * @endcode
-   *
-   * @param slot The signal handler, which should have a @c void return type,
-   *        usually created with sigc::mem_fun() or sigc::ptr_fun().
-   * @param after Whether this signal handler should be called before or after the default signal handler.
-   */
-  sigc::connection connect_notify(const VoidSlotType& slot, bool after = false)
-    { return sigc::connection(connect_notify_(slot, after)); }
-};
-
-
-/**** Glib::SignalProxy5 ***************************************************/
-
-/** Proxy for signals with 5 arguments.
- * Use the connect() or connect_notify() method, with sigc::mem_fun() or sigc::ptr_fun()
- * to connect signal handlers to signals.
- */
-template <class R,class P1,class P2,class P3,class P4,class P5>
-class SignalProxy5 : public SignalProxyNormal
-{
-public:
-  typedef sigc::slot<R,P1,P2,P3,P4,P5>    SlotType;
-  typedef sigc::slot<void,P1,P2,P3,P4,P5> VoidSlotType;
-
-  SignalProxy5(ObjectBase* obj, const SignalProxyInfo* info)
-    : SignalProxyNormal(obj, info) {}
-
-  /** Connects a signal handler to a signal.
-   *
-   * For instance, connect( sigc::mem_fun(*this, &TheClass::on_something) );
-   *
-   * @param slot The signal handler, usually created with sigc::mem_fun() or sigc::ptr_fun().
-   * @param after Whether this signal handler should be called before or after the default signal handler.
-   */
-  sigc::connection connect(const SlotType& slot, bool after = true)
-    { return sigc::connection(connect_(slot, after)); }
-
-  /** Connects a signal handler without a return value to a signal.
-   * By default, the signal handler will be called before the default signal handler.
-   *
-   * For instance, connect_notify( sigc::mem_fun(*this, &TheClass::on_something) );
-   *
-   * If the signal requires signal handlers with a @c void return type,
-   * the only difference between connect() and connect_notify() is the default
-   * value of @a after.
-   *
-   * If the signal requires signal handlers with a return value of type T,
-   * connect_notify() binds <tt>return T()</tt> to the connected signal handler.
-   * For instance, if the return type is @c bool, the following two calls are equivalent.
-   * @code
-   * connect_notify( sigc::mem_fun(*this, &TheClass::on_something) );
-   * connect( sigc::bind_return<bool>(sigc::mem_fun(*this, &TheClass::on_something), false), false );
-   * @endcode
-   *
-   * @param slot The signal handler, which should have a @c void return type,
-   *        usually created with sigc::mem_fun() or sigc::ptr_fun().
-   * @param after Whether this signal handler should be called before or after the default signal handler.
-   */
-  sigc::connection connect_notify(const VoidSlotType& slot, bool after = false)
-    { return sigc::connection(connect_notify_(slot, after)); }
-};
-
-
-/**** Glib::SignalProxy6 ***************************************************/
-
-/** Proxy for signals with 6 arguments.
- * Use the connect() or connect_notify() method, with sigc::mem_fun() or sigc::ptr_fun()
- * to connect signal handlers to signals.
- */
-template <class R,class P1,class P2,class P3,class P4,class P5,class P6>
-class SignalProxy6 : public SignalProxyNormal
-{
-public:
-  typedef sigc::slot<R,P1,P2,P3,P4,P5,P6>    SlotType;
-  typedef sigc::slot<void,P1,P2,P3,P4,P5,P6> VoidSlotType;
-
-  SignalProxy6(ObjectBase* obj, const SignalProxyInfo* info)
-    : SignalProxyNormal(obj, info) {}
-
-  /** Connects a signal handler to a signal.
-   *
-   * For instance, connect( sigc::mem_fun(*this, &TheClass::on_something) );
-   *
-   * @param slot The signal handler, usually created with sigc::mem_fun() or sigc::ptr_fun().
-   * @param after Whether this signal handler should be called before or after the default signal handler.
-   */
-  sigc::connection connect(const SlotType& slot, bool after = true)
-    { return sigc::connection(connect_(slot, after)); }
-
-  /** Connects a signal handler without a return value to a signal.
-   * By default, the signal handler will be called before the default signal handler.
-   *
-   * For instance, connect_notify( sigc::mem_fun(*this, &TheClass::on_something) );
-   *
-   * If the signal requires signal handlers with a @c void return type,
-   * the only difference between connect() and connect_notify() is the default
-   * value of @a after.
-   *
-   * If the signal requires signal handlers with a return value of type T,
-   * connect_notify() binds <tt>return T()</tt> to the connected signal handler.
-   * For instance, if the return type is @c bool, the following two calls are equivalent.
-   * @code
-   * connect_notify( sigc::mem_fun(*this, &TheClass::on_something) );
-   * connect( sigc::bind_return<bool>(sigc::mem_fun(*this, &TheClass::on_something), false), false );
-   * @endcode
-   *
-   * @param slot The signal handler, which should have a @c void return type,
-   *        usually created with sigc::mem_fun() or sigc::ptr_fun().
-   * @param after Whether this signal handler should be called before or after the default signal handler.
-   */
-  sigc::connection connect_notify(const VoidSlotType& slot, bool after = false)
-    { return sigc::connection(connect_notify_(slot, after)); }
-};
-
-
-/**** Glib::SignalProxyDetailed0 ***************************************************/
-
-/** Proxy for signals with 0 arguments and possibly a detailed name.
- * Use the connect() or connect_notify() method, with sigc::mem_fun() or sigc::ptr_fun()
- * to connect signal handlers to signals.
- */
-template <class R>
-class SignalProxyDetailed0 : public SignalProxyDetailed
-{
-public:
-  typedef sigc::slot<R>    SlotType;
-  typedef sigc::slot<void> VoidSlotType;
-
-  SignalProxyDetailed0(ObjectBase* obj, const SignalProxyInfo* info, const Glib::ustring& detail_name)
-    : SignalProxyDetailed(obj, info, detail_name) {}
-
-  /** Connects a signal handler to a signal.
-   *
-   * For instance, connect( sigc::mem_fun(*this, &TheClass::on_something) );
-   *
-   * @param slot The signal handler, usually created with sigc::mem_fun() or sigc::ptr_fun().
-   * @param after Whether this signal handler should be called before or after the default signal handler.
-   */
-  sigc::connection connect(const SlotType& slot, bool after = true)
-    { return sigc::connection(connect_impl_(false, slot, after)); }
-
-  /** Connects a signal handler without a return value to a signal.
-   * By default, the signal handler will be called before the default signal handler.
-   *
-   * For instance, connect_notify( sigc::mem_fun(*this, &TheClass::on_something) );
-   *
-   * If the signal requires signal handlers with a @c void return type,
-   * the only difference between connect() and connect_notify() is the default
-   * value of @a after.
-   *
-   * If the signal requires signal handlers with a return value of type T,
-   * connect_notify() binds <tt>return T()</tt> to the connected signal handler.
-   * For instance, if the return type is @c bool, the following two calls are equivalent.
-   * @code
-   * connect_notify( sigc::mem_fun(*this, &TheClass::on_something) );
-   * connect( sigc::bind_return<bool>(sigc::mem_fun(*this, &TheClass::on_something), false), false );
-   * @endcode
-   *
-   * @param slot The signal handler, which should have a @c void return type,
-   *        usually created with sigc::mem_fun() or sigc::ptr_fun().
-   * @param after Whether this signal handler should be called before or after the default signal handler.
-   */
-  sigc::connection connect_notify(const VoidSlotType& slot, bool after = false)
-    { return sigc::connection(connect_impl_(true, slot, after)); }
-};
-
-
-/**** Glib::SignalProxyDetailed1 ***************************************************/
-
-/** Proxy for signals with 1 arguments and possibly a detailed name.
- * Use the connect() or connect_notify() method, with sigc::mem_fun() or sigc::ptr_fun()
- * to connect signal handlers to signals.
- */
-template <class R,class P1>
-class SignalProxyDetailed1 : public SignalProxyDetailed
-{
-public:
-  typedef sigc::slot<R,P1>    SlotType;
-  typedef sigc::slot<void,P1> VoidSlotType;
-
-  SignalProxyDetailed1(ObjectBase* obj, const SignalProxyInfo* info, const Glib::ustring& detail_name)
-    : SignalProxyDetailed(obj, info, detail_name) {}
-
-  /** Connects a signal handler to a signal.
-   *
-   * For instance, connect( sigc::mem_fun(*this, &TheClass::on_something) );
-   *
-   * @param slot The signal handler, usually created with sigc::mem_fun() or sigc::ptr_fun().
-   * @param after Whether this signal handler should be called before or after the default signal handler.
-   */
-  sigc::connection connect(const SlotType& slot, bool after = true)
-    { return sigc::connection(connect_impl_(false, slot, after)); }
-
-  /** Connects a signal handler without a return value to a signal.
-   * By default, the signal handler will be called before the default signal handler.
-   *
-   * For instance, connect_notify( sigc::mem_fun(*this, &TheClass::on_something) );
-   *
-   * If the signal requires signal handlers with a @c void return type,
-   * the only difference between connect() and connect_notify() is the default
-   * value of @a after.
-   *
-   * If the signal requires signal handlers with a return value of type T,
-   * connect_notify() binds <tt>return T()</tt> to the connected signal handler.
-   * For instance, if the return type is @c bool, the following two calls are equivalent.
-   * @code
-   * connect_notify( sigc::mem_fun(*this, &TheClass::on_something) );
-   * connect( sigc::bind_return<bool>(sigc::mem_fun(*this, &TheClass::on_something), false), false );
-   * @endcode
-   *
-   * @param slot The signal handler, which should have a @c void return type,
-   *        usually created with sigc::mem_fun() or sigc::ptr_fun().
-   * @param after Whether this signal handler should be called before or after the default signal handler.
-   */
-  sigc::connection connect_notify(const VoidSlotType& slot, bool after = false)
-    { return sigc::connection(connect_impl_(true, slot, after)); }
-};
-
-
-/**** Glib::SignalProxyDetailed2 ***************************************************/
-
-/** Proxy for signals with 2 arguments and possibly a detailed name.
- * Use the connect() or connect_notify() method, with sigc::mem_fun() or sigc::ptr_fun()
- * to connect signal handlers to signals.
- */
-template <class R,class P1,class P2>
-class SignalProxyDetailed2 : public SignalProxyDetailed
-{
-public:
-  typedef sigc::slot<R,P1,P2>    SlotType;
-  typedef sigc::slot<void,P1,P2> VoidSlotType;
-
-  SignalProxyDetailed2(ObjectBase* obj, const SignalProxyInfo* info, const Glib::ustring& detail_name)
-    : SignalProxyDetailed(obj, info, detail_name) {}
-
-  /** Connects a signal handler to a signal.
-   *
-   * For instance, connect( sigc::mem_fun(*this, &TheClass::on_something) );
-   *
-   * @param slot The signal handler, usually created with sigc::mem_fun() or sigc::ptr_fun().
-   * @param after Whether this signal handler should be called before or after the default signal handler.
-   */
-  sigc::connection connect(const SlotType& slot, bool after = true)
-    { return sigc::connection(connect_impl_(false, slot, after)); }
-
-  /** Connects a signal handler without a return value to a signal.
-   * By default, the signal handler will be called before the default signal handler.
-   *
-   * For instance, connect_notify( sigc::mem_fun(*this, &TheClass::on_something) );
-   *
-   * If the signal requires signal handlers with a @c void return type,
-   * the only difference between connect() and connect_notify() is the default
-   * value of @a after.
-   *
-   * If the signal requires signal handlers with a return value of type T,
-   * connect_notify() binds <tt>return T()</tt> to the connected signal handler.
-   * For instance, if the return type is @c bool, the following two calls are equivalent.
-   * @code
-   * connect_notify( sigc::mem_fun(*this, &TheClass::on_something) );
-   * connect( sigc::bind_return<bool>(sigc::mem_fun(*this, &TheClass::on_something), false), false );
-   * @endcode
-   *
-   * @param slot The signal handler, which should have a @c void return type,
-   *        usually created with sigc::mem_fun() or sigc::ptr_fun().
-   * @param after Whether this signal handler should be called before or after the default signal handler.
-   */
-  sigc::connection connect_notify(const VoidSlotType& slot, bool after = false)
-    { return sigc::connection(connect_impl_(true, slot, after)); }
-};
-
-
-/**** Glib::SignalProxyDetailed3 ***************************************************/
-
-/** Proxy for signals with 3 arguments and possibly a detailed name.
- * Use the connect() or connect_notify() method, with sigc::mem_fun() or sigc::ptr_fun()
- * to connect signal handlers to signals.
+ 
+// Shared portion of a Signal with detail
+/** The SignalProxy provides an API similar to sigc::signal that can be used to
+ * connect sigc::slots to glib signals.
+ *
+ * This holds the name of the glib signal, including the detail name if any,
+ * and the object which might emit it. Actually, proxies are controlled by
+ * the template derivatives, which serve as gatekeepers for the
+ * types allowed on a particular signal.
  */
-template <class R,class P1,class P2,class P3>
-class SignalProxyDetailed3 : public SignalProxyDetailed
+class SignalProxyDetailed : public SignalProxyBase
 {
 public:
-  typedef sigc::slot<R,P1,P2,P3>    SlotType;
-  typedef sigc::slot<void,P1,P2,P3> VoidSlotType;
+  ~SignalProxyDetailed() noexcept;
 
-  SignalProxyDetailed3(ObjectBase* obj, const SignalProxyInfo* info, const Glib::ustring& detail_name)
-    : SignalProxyDetailed(obj, info, detail_name) {}
+  /// Stops the current signal emission (not in libsigc++)
+  void emission_stop();
 
-  /** Connects a signal handler to a signal.
-   *
-   * For instance, connect( sigc::mem_fun(*this, &TheClass::on_something) );
-   *
-   * @param slot The signal handler, usually created with sigc::mem_fun() or sigc::ptr_fun().
-   * @param after Whether this signal handler should be called before or after the default signal handler.
-   */
-  sigc::connection connect(const SlotType& slot, bool after = true)
-    { return sigc::connection(connect_impl_(false, slot, after)); }
+protected:
 
-  /** Connects a signal handler without a return value to a signal.
-   * By default, the signal handler will be called before the default signal handler.
-   *
-   * For instance, connect_notify( sigc::mem_fun(*this, &TheClass::on_something) );
-   *
-   * If the signal requires signal handlers with a @c void return type,
-   * the only difference between connect() and connect_notify() is the default
-   * value of @a after.
-   *
-   * If the signal requires signal handlers with a return value of type T,
-   * connect_notify() binds <tt>return T()</tt> to the connected signal handler.
-   * For instance, if the return type is @c bool, the following two calls are equivalent.
-   * @code
-   * connect_notify( sigc::mem_fun(*this, &TheClass::on_something) );
-   * connect( sigc::bind_return<bool>(sigc::mem_fun(*this, &TheClass::on_something), false), false );
-   * @endcode
-   *
-   * @param slot The signal handler, which should have a @c void return type,
-   *        usually created with sigc::mem_fun() or sigc::ptr_fun().
-   * @param after Whether this signal handler should be called before or after the default signal handler.
+  /** Creates a proxy for a signal that can be emitted by @a obj.
+   * @param obj The object that can emit the signal.
+   * @param info Information about the signal, including its name
+   *             and the C callbacks that should be called by glib.
+   * @param detail_name The detail name, if any.
    */
-  sigc::connection connect_notify(const VoidSlotType& slot, bool after = false)
-    { return sigc::connection(connect_impl_(true, slot, after)); }
-};
-
-
-/**** Glib::SignalProxyDetailed4 ***************************************************/
-
-/** Proxy for signals with 4 arguments and possibly a detailed name.
- * Use the connect() or connect_notify() method, with sigc::mem_fun() or sigc::ptr_fun()
- * to connect signal handlers to signals.
- */
-template <class R,class P1,class P2,class P3,class P4>
-class SignalProxyDetailed4 : public SignalProxyDetailed
-{
-public:
-  typedef sigc::slot<R,P1,P2,P3,P4>    SlotType;
-  typedef sigc::slot<void,P1,P2,P3,P4> VoidSlotType;
-
-  SignalProxyDetailed4(ObjectBase* obj, const SignalProxyInfo* info, const Glib::ustring& detail_name)
-    : SignalProxyDetailed(obj, info, detail_name) {}
+  SignalProxyDetailed(Glib::ObjectBase* obj, const SignalProxyInfo* info, const Glib::ustring& detail_name);
 
   /** Connects a signal handler to a signal.
+   * This is called by connect() and connect_notify() in derived SignalProxy classes.
    *
-   * For instance, connect( sigc::mem_fun(*this, &TheClass::on_something) );
-   *
+   * @param notify Whether this method is called by connect_notify() or by connect().
    * @param slot The signal handler, usually created with sigc::mem_fun() or sigc::ptr_fun().
    * @param after Whether this signal handler should be called before or after the default signal handler.
    */
-  sigc::connection connect(const SlotType& slot, bool after = true)
-    { return sigc::connection(connect_impl_(false, slot, after)); }
-
-  /** Connects a signal handler without a return value to a signal.
-   * By default, the signal handler will be called before the default signal handler.
-   *
-   * For instance, connect_notify( sigc::mem_fun(*this, &TheClass::on_something) );
-   *
-   * If the signal requires signal handlers with a @c void return type,
-   * the only difference between connect() and connect_notify() is the default
-   * value of @a after.
-   *
-   * If the signal requires signal handlers with a return value of type T,
-   * connect_notify() binds <tt>return T()</tt> to the connected signal handler.
-   * For instance, if the return type is @c bool, the following two calls are equivalent.
-   * @code
-   * connect_notify( sigc::mem_fun(*this, &TheClass::on_something) );
-   * connect( sigc::bind_return<bool>(sigc::mem_fun(*this, &TheClass::on_something), false), false );
-   * @endcode
-   *
-   * @param slot The signal handler, which should have a @c void return type,
-   *        usually created with sigc::mem_fun() or sigc::ptr_fun().
-   * @param after Whether this signal handler should be called before or after the default signal handler.
-   */
-  sigc::connection connect_notify(const VoidSlotType& slot, bool after = false)
-    { return sigc::connection(connect_impl_(true, slot, after)); }
-};
-
-
-/**** Glib::SignalProxyDetailed5 ***************************************************/
-
-/** Proxy for signals with 5 arguments and possibly a detailed name.
- * Use the connect() or connect_notify() method, with sigc::mem_fun() or sigc::ptr_fun()
- * to connect signal handlers to signals.
- */
-template <class R,class P1,class P2,class P3,class P4,class P5>
-class SignalProxyDetailed5 : public SignalProxyDetailed
-{
-public:
-  typedef sigc::slot<R,P1,P2,P3,P4,P5>    SlotType;
-  typedef sigc::slot<void,P1,P2,P3,P4,P5> VoidSlotType;
-
-  SignalProxyDetailed5(ObjectBase* obj, const SignalProxyInfo* info, const Glib::ustring& detail_name)
-    : SignalProxyDetailed(obj, info, detail_name) {}
+  sigc::slot_base& connect_impl_(bool notify, const sigc::slot_base& slot, bool after);
 
-  /** Connects a signal handler to a signal.
-   *
-   * For instance, connect( sigc::mem_fun(*this, &TheClass::on_something) );
-   *
-   * @param slot The signal handler, usually created with sigc::mem_fun() or sigc::ptr_fun().
-   * @param after Whether this signal handler should be called before or after the default signal handler.
-   */
-  sigc::connection connect(const SlotType& slot, bool after = true)
-    { return sigc::connection(connect_impl_(false, slot, after)); }
+private:
+  const SignalProxyInfo* info_; // Pointer to statically allocated structure.
+  const Glib::ustring detailed_name_; // signal_name[::detail_name]
 
-  /** Connects a signal handler without a return value to a signal.
-   * By default, the signal handler will be called before the default signal handler.
-   *
-   * For instance, connect_notify( sigc::mem_fun(*this, &TheClass::on_something) );
-   *
-   * If the signal requires signal handlers with a @c void return type,
-   * the only difference between connect() and connect_notify() is the default
-   * value of @a after.
-   *
-   * If the signal requires signal handlers with a return value of type T,
-   * connect_notify() binds <tt>return T()</tt> to the connected signal handler.
-   * For instance, if the return type is @c bool, the following two calls are equivalent.
-   * @code
-   * connect_notify( sigc::mem_fun(*this, &TheClass::on_something) );
-   * connect( sigc::bind_return<bool>(sigc::mem_fun(*this, &TheClass::on_something), false), false );
-   * @endcode
-   *
-   * @param slot The signal handler, which should have a @c void return type,
-   *        usually created with sigc::mem_fun() or sigc::ptr_fun().
-   * @param after Whether this signal handler should be called before or after the default signal handler.
-   */
-  sigc::connection connect_notify(const VoidSlotType& slot, bool after = false)
-    { return sigc::connection(connect_impl_(true, slot, after)); }
+  // no copy assignment
+  SignalProxyDetailed& operator=(const SignalProxyDetailed&);
 };
 
-
-/**** Glib::SignalProxyDetailed6 ***************************************************/
-
-/** Proxy for signals with 6 arguments and possibly a detailed name.
+/** Proxy for signals with any number of arguments and possibly a detailed name.
  * Use the connect() or connect_notify() method, with sigc::mem_fun() or sigc::ptr_fun()
  * to connect signal handlers to signals.
  */
-template <class R,class P1,class P2,class P3,class P4,class P5,class P6>
-class SignalProxyDetailed6 : public SignalProxyDetailed
+template <class R,class ...T>
+class SignalProxyDetailedAnyType : public SignalProxyDetailed
 {
 public:
-  typedef sigc::slot<R,P1,P2,P3,P4,P5,P6>    SlotType;
-  typedef sigc::slot<void,P1,P2,P3,P4,P5,P6> VoidSlotType;
+  typedef sigc::slot<R,T...>    SlotType;
+  typedef sigc::slot<void,T...> VoidSlotType;
 
-  SignalProxyDetailed6(ObjectBase* obj, const SignalProxyInfo* info, const Glib::ustring& detail_name)
+  SignalProxyDetailedAnyType(ObjectBase* obj, const SignalProxyInfo* info, const Glib::ustring& detail_name)
     : SignalProxyDetailed(obj, info, detail_name) {}
 
   /** Connects a signal handler to a signal.
@@ -888,6 +297,25 @@
     { return sigc::connection(connect_impl_(true, slot, after)); }
 };
 
+/* Templates below has been added to avoid API break, and should not be
+ * used in a newly created code. SignalProxyDetailedAnyType class should be
+ * used instead of SignalProxyDetailed# class.
+ */
+template <typename R>
+using SignalProxyDetailed0 = SignalProxyDetailedAnyType<R>;
+template <typename R, typename T1>
+using SignalProxyDetailed1 = SignalProxyDetailedAnyType<R, T1>;
+template <typename R, typename T1, typename T2>
+using SignalProxyDetailed2 = SignalProxyDetailedAnyType<R, T1, T2>;
+template <typename R, typename T1, typename T2, typename T3>
+using SignalProxyDetailed3 = SignalProxyDetailedAnyType<R, T1, T2, T3>;
+template <typename R, typename T1, typename T2, typename T3, typename T4>
+using SignalProxyDetailed4 = SignalProxyDetailedAnyType<R, T1, T2, T3, T4>;
+template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5>
+using SignalProxyDetailed5 = SignalProxyDetailedAnyType<R, T1, T2, T3, T4, T5>;
+template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
+using SignalProxyDetailed6 = SignalProxyDetailedAnyType<R, T1, T2, T3, T4, T5, T6>;
+ 
 } // namespace Glib
 
 #endif /* _GLIBMM_SIGNALPROXY_H */
diff '--exclude=.git' -urN a/glib/src/filelist.am b/glib/src/filelist.am
--- a/glib/src/filelist.am	2016-04-14 09:15:01.000000000 -0500
+++ b/glib/src/filelist.am	2019-04-10 17:13:07.572131907 -0500
@@ -59,5 +59,5 @@
 glibmm_files_ccg = $(glibmm_files_hg:.hg=.ccg)
 
 glibmm_files_cc_m4 = value_basictypes.cc.m4 variant_basictypes.cc.m4
-glibmm_files_h_m4  = signalproxy.h.m4 value_basictypes.h.m4 \
+glibmm_files_h_m4  = value_basictypes.h.m4 \
 	variant_basictypes.h.m4
diff '--exclude=.git' -urN a/glib/src/signalproxy.h.m4 b/glib/src/signalproxy.h.m4
--- a/glib/src/signalproxy.h.m4	2016-04-14 09:15:01.000000000 -0500
+++ b/glib/src/signalproxy.h.m4	1969-12-31 18:00:00.000000000 -0600
@@ -1,267 +0,0 @@
-dnl Glib SignalProxy Templates
-dnl 
-dnl  Copyright 2001 Free Software Foundation
-dnl  Copyright 1999 Karl Nelson <kenelson@ece.ucdavis.edu>
-dnl 
-dnl  This library is free software; you can redistribute it and/or
-dnl  modify it under the terms of the GNU Lesser General Public
-dnl  License as published by the Free Software Foundation; either
-dnl  version 2.1 of the License, or (at your option) any later version.
-dnl 
-dnl  This library is distributed in the hope that it will be useful,
-dnl  but WITHOUT ANY WARRANTY; without even the implied warranty of
-dnl  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-dnl  Lesser General Public License for more details.
-dnl 
-dnl  You should have received a copy of the GNU Lesser General Public
-dnl  License along with this library; if not, write to the Free
-dnl  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-dnl 
-/* This is a generated file, do not edit.  Generated from __file__ */
-include(template.macros.m4)
-#ifndef __header__
-#define __header__
-
-extern "C"
-{
-  typedef void (*GCallback) (void);
-  typedef struct _GObject GObject;
-}
-
-#include <sigc++/sigc++.h>
-#include <glibmm/signalproxy_connectionnode.h>
-#include <glibmm/ustring.h>
-
-namespace Glib
-{
-
-// Forward declarations
-class ObjectBase;
-
-#ifndef DOXYGEN_SHOULD_SKIP_THIS
-
-struct SignalProxyInfo
-{
-  const char* signal_name;
-  GCallback   callback;
-  GCallback   notify_callback;
-};
-
-#endif //DOXYGEN_SHOULD_SKIP_THIS
-
-// This base class is used by SignalProxyNormal, SignalProxyDetailed and SignalProxyProperty.
-class SignalProxyBase
-{
-public:
-  SignalProxyBase(Glib::ObjectBase* obj);
-
-#ifndef DOXYGEN_SHOULD_SKIP_THIS
-  static inline sigc::slot_base* data_to_slot(void* data)
-  {
-    const auto pConnectionNode = static_cast<SignalProxyConnectionNode*>(data);
-
-    // Return 0 if the connection is blocked.
-    return (!pConnectionNode->slot_.blocked()) ? &pConnectionNode->slot_ : 0;
-  }
-#endif /* DOXYGEN_SHOULD_SKIP_THIS */
-
-protected:
-  ObjectBase* obj_;
-
-private:
-  SignalProxyBase& operator=(const SignalProxyBase&); // not implemented
-};
-
-
-// Shared portion of a Signal without detail
-/** The SignalProxy provides an API similar to sigc::signal that can be used to
- * connect sigc::slots to glib signals.
- *
- * This holds the name of the glib signal and the object
- * which might emit it. Actually, proxies are controlled by
- * the template derivatives, which serve as gatekeepers for the
- * types allowed on a particular signal.
- *
- * For signals with a detailed name (signal_name::detail_name) see SignalProxyDetailed.
- */
-class SignalProxyNormal : public SignalProxyBase
-{
-public:
-  ~SignalProxyNormal() noexcept;
-
-  /// Stops the current signal emission (not in libsigc++)
-  void emission_stop();
-
-#ifndef DOXYGEN_SHOULD_SKIP_THIS
-  // This callback for SignalProxy0<void>
-  // is defined here to avoid code duplication.
-  static void slot0_void_callback(GObject*, void* data);
-#endif
-
-protected:
-
-  /** Creates a proxy for a signal that can be emitted by @a obj.
-   * @param obj The object that can emit the signal.
-   * @param info Information about the signal, including its name, and the C callbacks that should be called by glib.
-   */
-  SignalProxyNormal(Glib::ObjectBase* obj, const SignalProxyInfo* info);
-
-  /** Connects a generic signal handler to a signal.
-   * This is called by connect() in derived SignalProxy classes.
-   *
-   * @param slot The signal handler, usually created with sigc::mem_fun() or sigc::ptr_fun().
-   * @param after Whether this signal handler should be called before or after the default signal handler.
-   */
-  sigc::slot_base& connect_(const sigc::slot_base& slot, bool after);
-
-  /** Connects a signal handler without a return value to a signal.
-   * This is called by connect_notify() in derived SignalProxy classes.
-   *
-   * @param slot The signal handler, which should have a @c void return type,
-   *        usually created with sigc::mem_fun() or sigc::ptr_fun().
-   * @param after Whether this signal handler should be called before or after the default signal handler.
-   */
-  sigc::slot_base& connect_notify_(const sigc::slot_base& slot, bool after);
-
-private:
-  const SignalProxyInfo* info_;
-
-  //TODO: We could maybe replace both connect_() and connect_notify_() with this in future, because they don't do anything extra.
-  /** This is called by connect_() and connect_notify_().
-   */
-  sigc::slot_base& connect_impl_(GCallback callback, const sigc::slot_base& slot, bool after);
-
-  // no copy assignment
-  SignalProxyNormal& operator=(const SignalProxyNormal&);
-};
-
-// Shared portion of a Signal with detail
-/** The SignalProxy provides an API similar to sigc::signal that can be used to
- * connect sigc::slots to glib signals.
- *
- * This holds the name of the glib signal, including the detail name if any,
- * and the object which might emit it. Actually, proxies are controlled by
- * the template derivatives, which serve as gatekeepers for the
- * types allowed on a particular signal.
- */
-class SignalProxyDetailed : public SignalProxyBase
-{
-public:
-  ~SignalProxyDetailed() noexcept;
-
-  /// Stops the current signal emission (not in libsigc++)
-  void emission_stop();
-
-protected:
-
-  /** Creates a proxy for a signal that can be emitted by @a obj.
-   * @param obj The object that can emit the signal.
-   * @param info Information about the signal, including its name
-   *             and the C callbacks that should be called by glib.
-   * @param detail_name The detail name, if any.
-   */
-  SignalProxyDetailed(Glib::ObjectBase* obj, const SignalProxyInfo* info, const Glib::ustring& detail_name);
-
-  /** Connects a signal handler to a signal.
-   * This is called by connect() and connect_notify() in derived SignalProxy classes.
-   *
-   * @param notify Whether this method is called by connect_notify() or by connect().
-   * @param slot The signal handler, usually created with sigc::mem_fun() or sigc::ptr_fun().
-   * @param after Whether this signal handler should be called before or after the default signal handler.
-   */
-  sigc::slot_base& connect_impl_(bool notify, const sigc::slot_base& slot, bool after);
-
-private:
-  const SignalProxyInfo* info_; // Pointer to statically allocated structure.
-  const Glib::ustring detailed_name_; // signal_name[[::detail_name]]dnl one pair of [] in the generated .h file
-
-
-  // no copy assignment
-  SignalProxyDetailed& operator=(const SignalProxyDetailed&);
-};
-
-dnl
-dnl GLIB_SIGNAL_PROXY([P1, P2, ...], Normal or Detailed)
-dnl
-define([GLIB_SIGNAL_PROXY],[dnl
-LINE(]__line__[)dnl
-
-/**** Glib::[SignalProxy]ifelse($2,Normal,,$2)[]NUM($1) ***************************************************/
-
-/** Proxy for signals with NUM($1) arguments[]ifelse($2,Normal,,[ and possibly a detailed name]).
- * Use the connect() or connect_notify() method, with sigc::mem_fun() or sigc::ptr_fun()
- * to connect signal handlers to signals.
- */
-template <LIST(class R,ARG_CLASS($1))>
-class [SignalProxy]ifelse($2,Normal,,$2)[]NUM($1) : public SignalProxy$2
-{
-public:
-  typedef sigc::slot<LIST(R,ARG_TYPE($1))>    SlotType;
-  typedef sigc::slot<LIST(void,ARG_TYPE($1))> VoidSlotType;
-
-ifelse($2,Normal,dnl
-  [SignalProxy]NUM($1)[(ObjectBase* obj, const SignalProxyInfo* info)
-    : SignalProxyNormal(obj, info) {}
-],dnl Detailed
-  [SignalProxyDetailed]NUM($1)[(ObjectBase* obj, const SignalProxyInfo* info, const Glib::ustring& detail_name)
-    : SignalProxyDetailed(obj, info, detail_name) {}
-])dnl
-
-  /** Connects a signal handler to a signal.
-   *
-   * For instance, connect( sigc::mem_fun(*this, &TheClass::on_something) );
-   *
-   * @param slot The signal handler, usually created with sigc::mem_fun() or sigc::ptr_fun().
-   * @param after Whether this signal handler should be called before or after the default signal handler.
-   */
-  sigc::connection connect(const SlotType& slot, bool after = true)
-    { return sigc::connection(ifelse($2,Normal,[connect_(slot, after)],[connect_impl_(false, slot, after)])); }
-
-  /** Connects a signal handler without a return value to a signal.
-   * By default, the signal handler will be called before the default signal handler.
-   *
-   * For instance, connect_notify( sigc::mem_fun(*this, &TheClass::on_something) );
-   *
-   * If the signal requires signal handlers with a @c void return type,
-   * the only difference between connect() and connect_notify() is the default
-   * value of @a after.
-   *
-   * If the signal requires signal handlers with a return value of type T,
-   * connect_notify() binds <tt>return T()</tt> to the connected signal handler.
-   * For instance, if the return type is @c bool, the following two calls are equivalent.
-   * @code
-   * connect_notify( sigc::mem_fun(*this, &TheClass::on_something) );
-   * connect( sigc::bind_return<bool>(sigc::mem_fun(*this, &TheClass::on_something), false), false );
-   * @endcode
-   *
-   * @param slot The signal handler, which should have a @c void return type,
-   *        usually created with sigc::mem_fun() or sigc::ptr_fun().
-   * @param after Whether this signal handler should be called before or after the default signal handler.
-   */
-  sigc::connection connect_notify(const VoidSlotType& slot, bool after = false)
-    { return sigc::connection(ifelse($2,Normal,[connect_notify_(slot, after)],[connect_impl_(true, slot, after)])); }
-};
-])dnl
-dnl
-dnl Template forms of SignalProxy
-dnl
-GLIB_SIGNAL_PROXY(ARGS(P,0), Normal)
-GLIB_SIGNAL_PROXY(ARGS(P,1), Normal)
-GLIB_SIGNAL_PROXY(ARGS(P,2), Normal)
-GLIB_SIGNAL_PROXY(ARGS(P,3), Normal)
-GLIB_SIGNAL_PROXY(ARGS(P,4), Normal)
-GLIB_SIGNAL_PROXY(ARGS(P,5), Normal)
-GLIB_SIGNAL_PROXY(ARGS(P,6), Normal)
-dnl
-GLIB_SIGNAL_PROXY(ARGS(P,0), Detailed)
-GLIB_SIGNAL_PROXY(ARGS(P,1), Detailed)
-GLIB_SIGNAL_PROXY(ARGS(P,2), Detailed)
-GLIB_SIGNAL_PROXY(ARGS(P,3), Detailed)
-GLIB_SIGNAL_PROXY(ARGS(P,4), Detailed)
-GLIB_SIGNAL_PROXY(ARGS(P,5), Detailed)
-GLIB_SIGNAL_PROXY(ARGS(P,6), Detailed)
-dnl
-} // namespace Glib
-
-#endif /* __header__ */
-
diff '--exclude=.git' -urN a/tools/m4/signal.m4 b/tools/m4/signal.m4
--- a/tools/m4/signal.m4	2016-04-14 09:15:01.000000000 -0500
+++ b/tools/m4/signal.m4	2019-04-10 17:13:07.573131903 -0500
@@ -24,17 +24,17 @@
 ')dnl
 ifelse($13,,`dnl no detail_name
 $10
-  Glib::SignalProxy`'_NUM($6)< $5`'_COMMA_PREFIX($6) > signal_$4`'();
+  Glib::SignalProxy< $5`'_COMMA_PREFIX($6) > signal_$4`'();
 ',dnl detail_name
 $14,0,`dnl
 $10
-  Glib::SignalProxyDetailed`'_NUM($6)< $5`'_COMMA_PREFIX($6) > signal_$4`'(const Glib::ustring& $13 = Glib::ustring());
+  Glib::SignalProxyDetailedAnyType< $5`'_COMMA_PREFIX($6) > signal_$4`'(const Glib::ustring& $13 = Glib::ustring());
 ',`dnl detail_name and two_signal_methods
 $10
-  Glib::SignalProxy`'_NUM($6)< $5`'_COMMA_PREFIX($6) > signal_$4`'();
+  Glib::SignalProxy< $5`'_COMMA_PREFIX($6) > signal_$4`'();
 
 $10
-  Glib::SignalProxyDetailed`'_NUM($6)< $5`'_COMMA_PREFIX($6) > signal_$4`'(const Glib::ustring& $13);
+  Glib::SignalProxyDetailedAnyType< $5`'_COMMA_PREFIX($6) > signal_$4`'(const Glib::ustring& $13);
 ')dnl end detail_name
 ifelse(`$9',,,`_DEPRECATE_IFDEF_END
 ')dnl
@@ -161,25 +161,25 @@
 ifelse(`$9',,,`_DEPRECATE_IFDEF_START
 ')dnl
 ifelse($13,,`dnl no detail_name
-Glib::SignalProxy`'_NUM($6)< $5`'_COMMA_PREFIX($6) > __CPPNAME__::signal_$4`'()
+Glib::SignalProxy< $5`'_COMMA_PREFIX($6) > __CPPNAME__::signal_$4`'()
 {
-  return Glib::SignalProxy`'_NUM($6)< $5`'_COMMA_PREFIX($6) >(this, &__CPPNAME__`'_signal_$4_info);
+  return Glib::SignalProxy< $5`'_COMMA_PREFIX($6) >(this, &__CPPNAME__`'_signal_$4_info);
 }
 ',dnl detail_name
 $14,0,`dnl
-Glib::SignalProxyDetailed`'_NUM($6)< $5`'_COMMA_PREFIX($6) > __CPPNAME__::signal_$4`'(const Glib::ustring& $13)
+Glib::SignalProxyDetailedAnyType< $5`'_COMMA_PREFIX($6) > __CPPNAME__::signal_$4`'(const Glib::ustring& $13)
 {
-  return Glib::SignalProxyDetailed`'_NUM($6)< $5`'_COMMA_PREFIX($6) >(this, &__CPPNAME__`'_signal_$4_info, $13);
+  return Glib::SignalProxyDetailedAnyType< $5`'_COMMA_PREFIX($6) >(this, &__CPPNAME__`'_signal_$4_info, $13);
 }
 ',`dnl detail_name and two_signal_methods
-Glib::SignalProxy`'_NUM($6)< $5`'_COMMA_PREFIX($6) > __CPPNAME__::signal_$4`'()
+Glib::SignalProxy< $5`'_COMMA_PREFIX($6) > __CPPNAME__::signal_$4`'()
 {
-  return Glib::SignalProxy`'_NUM($6)< $5`'_COMMA_PREFIX($6) >(this, &__CPPNAME__`'_signal_$4_info);
+  return Glib::SignalProxy< $5`'_COMMA_PREFIX($6) >(this, &__CPPNAME__`'_signal_$4_info);
 }
 
-Glib::SignalProxyDetailed`'_NUM($6)< $5`'_COMMA_PREFIX($6) > __CPPNAME__::signal_$4`'(const Glib::ustring& $13)
+Glib::SignalProxyDetailedAnyType< $5`'_COMMA_PREFIX($6) > __CPPNAME__::signal_$4`'(const Glib::ustring& $13)
 {
-  return Glib::SignalProxyDetailed`'_NUM($6)< $5`'_COMMA_PREFIX($6) >(this, &__CPPNAME__`'_signal_$4_info, $13);
+  return Glib::SignalProxyDetailedAnyType< $5`'_COMMA_PREFIX($6) >(this, &__CPPNAME__`'_signal_$4_info, $13);
 }
 ')dnl end detail_name
 ifelse(`$9',,,`_DEPRECATE_IFDEF_END
