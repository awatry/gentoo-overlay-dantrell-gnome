diff '--exclude=.git' -urN a/configure.ac b/configure.ac
--- a/configure.ac	2017-10-19 06:12:50.000000000 -0400
+++ b/configure.ac	2017-12-04 23:53:44.628324494 -0500
@@ -189,36 +189,30 @@
 dnl Suspend/resume support
 dnl
 
-PKG_CHECK_MODULES(LIBSYSTEMD, [libsystemd >= 209],[have_libsystemd=yes],[have_libsystemd=no])
-PKG_CHECK_MODULES(LIBSYSTEMD_LOGIN, [libsystemd-login >= 183],[have_libsystemd_login=yes],[have_libsystemd_login=no])
-AC_ARG_WITH(suspend-resume,
-            AS_HELP_STRING([--with-suspend-resume=no|systemd],
-                           [Enable suspend/resume support [[default=auto]]]),,
-            [with_suspend_resume=auto])
+AC_ARG_WITH(suspend-resume, AS_HELP_STRING([--with-suspend-resume=no|upower|systemd], [Build ModemManager with specific suspend/resume support]))
 
-if test "x$with_suspend_resume" = "xauto"; then
-    if test "x$have_libsystemd" = "xyes" || test "x$have_libsystemd_login" = "xyes"; then
-        with_suspend_resume=systemd
-    else
-        with_suspend_resume=no
-    fi
+if test "x$with_suspend_resume" = "x"; then
+   with_suspend_resume="no"
 fi
 
 case $with_suspend_resume in
     no)
         AC_DEFINE(WITH_SUSPEND_RESUME, 0, [Define if you have suspend-resume support])
         ;;
+    upower)
+        AC_DEFINE(WITH_SUSPEND_RESUME, 1, [Define if you have suspend-resume support])
+        ;;
     systemd)
-        if test "x$have_libsystemd" = "xno" && test "x$have_libsystemd_login" = "xno"; then
-		    AC_MSG_ERROR(libsystemd or libsystemd-login development headers are required)
-	    fi
+        PKG_CHECK_MODULES(SYSTEMD_INHIBIT, [libsystemd >= 209],,
+                          [PKG_CHECK_MODULES(SYSTEMD_INHIBIT, [libsystemd-login >= 183])])
         AC_DEFINE(WITH_SUSPEND_RESUME, 1, [Define if you have suspend-resume support])
         ;;
     *)
-        AC_MSG_ERROR([Wrong value for --with-suspend-resume: $with_suspend_resume])
+        AC_MSG_ERROR(--with-suspend-resume must be one of [no, upower, systemd])
         ;;
 esac
 
+AM_CONDITIONAL(SUSPEND_RESUME_UPOWER,  test "x$with_suspend_resume" = "xupower")
 AM_CONDITIONAL(SUSPEND_RESUME_SYSTEMD, test "x$with_suspend_resume" = "xsystemd")
 
 dnl-----------------------------------------------------------------------------
diff '--exclude=.git' -urN a/src/Makefile.am b/src/Makefile.am
--- a/src/Makefile.am	2017-10-19 06:03:02.000000000 -0400
+++ b/src/Makefile.am	2017-12-04 23:46:34.914585743 -0500
@@ -294,6 +294,11 @@
 ModemManager_SOURCES += mm-sleep-monitor.h mm-sleep-monitor.c
 endif
 
+# Additional suspend/resume support via upower
+if SUSPEND_RESUME_UPOWER
+ModemManager_SOURCES += mm-sleep-monitor.h mm-sleep-monitor-upower.c
+endif
+
 # Additional QMI support in ModemManager
 if WITH_QMI
 ModemManager_SOURCES += \
diff '--exclude=.git' -urN a/src/mm-sleep-monitor-upower.c b/src/mm-sleep-monitor-upower.c
--- a/src/mm-sleep-monitor-upower.c	1969-12-31 19:00:00.000000000 -0500
+++ b/src/mm-sleep-monitor-upower.c	2017-12-04 23:46:34.914585743 -0500
@@ -0,0 +1,150 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2012 Red Hat, Inc.
+ * Author: Matthias Clasen <mclasen@redhat.com>
+ *
+ * Port to GDBus:
+ * (C) Copyright 2015 Aleksander Morgado <aleksander@aleksander.es>
+ */
+
+#include "config.h"
+
+#include <errno.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <gio/gio.h>
+
+#include "mm-log.h"
+#include "mm-utils.h"
+#include "mm-sleep-monitor.h"
+
+#define UPOWER_NAME       "org.freedesktop.UPower"
+#define UPOWER_PATH       "/org/freedesktop/UPower"
+#define UPOWER_INTERFACE  "org.freedesktop.UPower"
+
+struct _MMSleepMonitor {
+    GObject parent_instance;
+
+    GDBusProxy *upower_proxy;
+};
+
+struct _MMSleepMonitorClass {
+    GObjectClass parent_class;
+
+    void (*sleeping) (MMSleepMonitor *monitor);
+    void (*resuming) (MMSleepMonitor *monitor);
+};
+
+
+enum {
+    SLEEPING,
+    RESUMING,
+    LAST_SIGNAL,
+};
+static guint signals[LAST_SIGNAL] = {0};
+
+G_DEFINE_TYPE (MMSleepMonitor, mm_sleep_monitor, G_TYPE_OBJECT);
+
+/********************************************************************/
+
+static void
+signal_cb (GDBusProxy  *proxy,
+           const gchar *sendername,
+           const gchar *signalname,
+           GVariant    *args,
+           gpointer     data)
+{
+    MMSleepMonitor *self = data;
+
+    if (strcmp (signalname, "Sleeping") == 0) {
+        mm_dbg ("[sleep-monitor] received UPower sleeping signal");
+        g_signal_emit (self, signals[SLEEPING], 0);
+    } else if (strcmp (signalname, "Resuming") == 0) {
+        mm_dbg ("[sleep-monitor] received UPower resuming signal");
+        g_signal_emit (self, signals[RESUMING], 0);
+    }
+}
+
+static void
+on_proxy_acquired (GObject *object,
+                   GAsyncResult *res,
+                   MMSleepMonitor *self)
+{
+    GError *error = NULL;
+
+    self->upower_proxy = g_dbus_proxy_new_for_bus_finish (res, &error);
+    if (!self->upower_proxy) {
+        mm_warn ("[sleep-monitor] failed to acquire UPower proxy: %s", error->message);
+        g_clear_error (&error);
+        return;
+    }
+
+    g_signal_connect (self->upower_proxy, "g-signal", G_CALLBACK (signal_cb), self);
+}
+
+static void
+mm_sleep_monitor_init (MMSleepMonitor *self)
+{
+    g_dbus_proxy_new_for_bus (G_BUS_TYPE_SYSTEM,
+                              G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START |
+                              G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES,
+                              NULL,
+                              UPOWER_NAME, UPOWER_PATH, UPOWER_INTERFACE,
+                              NULL,
+                              (GAsyncReadyCallback) on_proxy_acquired, self);
+}
+
+static void
+finalize (GObject *object)
+{
+    MMSleepMonitor *self = MM_SLEEP_MONITOR (object);
+
+    if (self->upower_proxy)
+        g_object_unref (self->upower_proxy);
+
+    if (G_OBJECT_CLASS (mm_sleep_monitor_parent_class)->finalize != NULL)
+        G_OBJECT_CLASS (mm_sleep_monitor_parent_class)->finalize (object);
+}
+
+static void
+mm_sleep_monitor_class_init (MMSleepMonitorClass *klass)
+{
+    GObjectClass *gobject_class;
+
+    gobject_class = G_OBJECT_CLASS (klass);
+
+    gobject_class->finalize = finalize;
+
+    signals[SLEEPING] = g_signal_new (MM_SLEEP_MONITOR_SLEEPING,
+                                      MM_TYPE_SLEEP_MONITOR,
+                                      G_SIGNAL_RUN_LAST,
+                                      G_STRUCT_OFFSET (MMSleepMonitorClass, sleeping),
+                                      NULL,                   /* accumulator      */
+                                      NULL,                   /* accumulator data */
+                                      g_cclosure_marshal_VOID__VOID,
+                                      G_TYPE_NONE, 0);
+    signals[RESUMING] = g_signal_new (MM_SLEEP_MONITOR_RESUMING,
+                                      MM_TYPE_SLEEP_MONITOR,
+                                      G_SIGNAL_RUN_LAST,
+                                      G_STRUCT_OFFSET (MMSleepMonitorClass, resuming),
+                                      NULL,                   /* accumulator      */
+                                      NULL,                   /* accumulator data */
+                                      g_cclosure_marshal_VOID__VOID,
+                                      G_TYPE_NONE, 0);
+}
+
+MM_DEFINE_SINGLETON_GETTER (MMSleepMonitor, mm_sleep_monitor_get, MM_TYPE_SLEEP_MONITOR);
